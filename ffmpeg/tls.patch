diff --git a/configure b/configure
index 4f5353f84b..787d2d3a92 100755
--- a/configure
+++ b/configure
@@ -314,6 +314,7 @@ External library support:
   --enable-decklink        enable Blackmagic DeckLink I/O support [no]
   --enable-mbedtls         enable mbedTLS, needed for https support
                            if openssl, gnutls or libtls is not used [no]
+  --enable-libnx           enable libnx, needed for https support
   --enable-mediacodec      enable Android MediaCodec support [no]
   --enable-mediafoundation enable encoding via MediaFoundation [auto]
   --disable-metal          disable Apple Metal framework [autodetect]
@@ -1847,6 +1848,7 @@ EXTERNAL_AUTODETECT_LIBRARY_LIST="
     mediafoundation
     metal
     schannel
+    libnx
     sdl2
     securetransport
     sndio
@@ -3752,7 +3754,7 @@ sctp_protocol_select="network"
 securetransport_conflict="openssl gnutls libtls mbedtls"
 srtp_protocol_select="rtp_protocol srtp"
 tcp_protocol_select="network"
-tls_protocol_deps_any="gnutls openssl schannel securetransport libtls mbedtls"
+tls_protocol_deps_any="gnutls openssl schannel securetransport libtls mbedtls libnx"
 tls_protocol_select="tcp_protocol"
 udp_protocol_select="network"
 udplite_protocol_select="network"
@@ -3775,7 +3777,7 @@ libsmbclient_protocol_deps="libsmbclient gplv3"
 libsrt_protocol_deps="libsrt"
 libsrt_protocol_select="network"
 libssh_protocol_deps="libssh"
-libtls_conflict="openssl gnutls mbedtls"
+libtls_conflict="openssl gnutls mbedtls libnx"
 libzmq_protocol_deps="libzmq"
 libzmq_protocol_select="network"
 
diff --git a/libavformat/Makefile b/libavformat/Makefile
index a89df7e9a3..ccf9abc2dd 100644
--- a/libavformat/Makefile
+++ b/libavformat/Makefile
@@ -701,6 +701,7 @@ OBJS-$(CONFIG_IPNS_GATEWAY_PROTOCOL)     += ipfsgateway.o
 TLS-OBJS-$(CONFIG_GNUTLS)                += tls_gnutls.o
 TLS-OBJS-$(CONFIG_LIBTLS)                += tls_libtls.o
 TLS-OBJS-$(CONFIG_MBEDTLS)               += tls_mbedtls.o
+TLS-OBJS-$(CONFIG_LIBNX)                 += tls_libnx.o
 TLS-OBJS-$(CONFIG_OPENSSL)               += tls_openssl.o
 TLS-OBJS-$(CONFIG_SECURETRANSPORT)       += tls_securetransport.o
 TLS-OBJS-$(CONFIG_SCHANNEL)              += tls_schannel.o
diff --git a/libavformat/tls_libnx.c b/libavformat/tls_libnx.c
new file mode 100644
index 0000000000..6d3de1eab3
--- /dev/null
+++ b/libavformat/tls_libnx.c
@@ -0,0 +1,187 @@
+/*
+ * TLS/SSL Protocol
+ * Copyright (c) 2018 Thomas Volkert
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <switch.h>
+
+#include "avformat.h"
+#include "internal.h"
+#include "url.h"
+#include "tls.h"
+#include "libavutil/parseutils.h"
+
+typedef struct TLSContext {
+    const AVClass *class;
+    TLSShared tls_shared;
+    SslContext context;
+    SslConnection conn;
+    char *priv_key_pw;
+} TLSContext;
+
+#define OFFSET(x) offsetof(TLSContext, x)
+
+static int tls_close(URLContext *h)
+{
+    TLSContext *tls_ctx = h->priv_data;
+
+    sslConnectionClose(&tls_ctx->conn);
+    sslContextClose(&tls_ctx->context);
+
+    ffurl_closep(&tls_ctx->tls_shared.tcp);
+    return 0;
+}
+
+static int tls_open(URLContext *h, const char *uri, int flags, AVDictionary **options)
+{
+    const size_t bufsize = 16384;
+    TLSContext *tls_ctx = h->priv_data;
+    TLSShared *shr = &tls_ctx->tls_shared;
+    int ret = 0;
+    Result rc = 0;
+    u8 *buffer = NULL;
+    u32 out_size = 0, total_certs = 0;
+
+    if ((ret = ff_tls_open_underlying(shr, h, uri, options)) < 0)
+        goto fail;
+
+    if (shr->listen) {
+        av_log(h, AV_LOG_ERROR, "TLS Listen Sockets with libnx is not implemented.\n");
+        ret = AVERROR(EINVAL);
+        goto fail;
+    }
+
+    rc = sslCreateContext(&tls_ctx->context, SslVersion_Auto);
+    if (R_FAILED(rc)) {
+        ret = AVERROR(EINVAL);
+        goto fail;
+    }
+
+    rc = sslContextCreateConnection(&tls_ctx->context, &tls_ctx->conn);
+
+    if (R_SUCCEEDED(rc)) {
+        rc = sslConnectionSetOption(&tls_ctx->conn, SslOptionType_DoNotCloseSocket, true);
+    }
+
+    if (R_SUCCEEDED(rc)) {
+        int *sockfd = (int *)((uint8_t *)shr->tcp->priv_data + sizeof(AVClass));
+        ret = socketSslConnectionSetSocketDescriptor(&tls_ctx->conn, *sockfd);
+        if (ret == -1 && errno != ENOENT) goto fail;
+    }
+
+    if (R_SUCCEEDED(rc)) {
+        rc = sslConnectionSetHostName(&tls_ctx->conn, shr->host, strlen(shr->host));
+    }
+
+    /* This will fail on system-versions where this option isn't available,
+     * so ignore errors from this. */
+    if (R_SUCCEEDED(rc)) {
+        sslConnectionSetOption(&tls_ctx->conn, SslOptionType_SkipDefaultVerify, true);
+    }
+
+    if (R_SUCCEEDED(rc) && hosversionAtLeast(3, 0, 0)) {
+        rc = sslConnectionSetOption(&tls_ctx->conn, SslOptionType_GetServerCertChain, true);
+    }
+
+    if (shr->verify) {
+        rc = sslConnectionSetVerifyOption(&tls_ctx->conn, SslVerifyOption_DateCheck);
+        if (R_FAILED(rc)) {
+            av_log(h, AV_LOG_ERROR, "sslConnectionSetVerifyOption returned: %u\n", rc);
+            goto fail;
+        }
+    }
+
+    // ssl handshake
+    buffer = calloc(1, bufsize);
+    rc = sslConnectionDoHandshake(&tls_ctx->conn, &out_size, &total_certs, buffer, bufsize);
+    if (R_FAILED(rc)) {
+        av_log(h, AV_LOG_ERROR, "sslConnectionDoHandshake returned: %u\n", rc);
+        goto fail;
+    }
+
+    free(buffer);
+    return 0;
+
+fail:
+    tls_close(h);
+    return AVERROR(EIO);
+}
+
+static int tls_read(URLContext *h, uint8_t *buf, int size)
+{
+    TLSContext *tls_ctx = h->priv_data;
+    Result rc = 0;
+    u32 out_size = 0;
+    rc = sslConnectionRead(&tls_ctx->conn, buf, size, &out_size);
+    if (R_SUCCEEDED(rc)) {
+        // return read length
+        return out_size;
+    }
+    return AVERROR(EIO);
+}
+
+static int tls_write(URLContext *h, const uint8_t *buf, int size)
+{
+    TLSContext *tls_ctx = h->priv_data;
+    Result rc = 0;
+    u32 out_size = 0;
+    rc = sslConnectionWrite(&tls_ctx->conn, buf, size, &out_size);
+    if (R_SUCCEEDED(rc)) {
+        // return written length
+        return out_size;
+    }
+    return AVERROR(EIO);
+}
+
+static int tls_get_file_handle(URLContext *h)
+{
+    TLSContext *c = h->priv_data;
+    return ffurl_get_file_handle(c->tls_shared.tcp);
+}
+
+static int tls_get_short_seek(URLContext *h)
+{
+    TLSContext *s = h->priv_data;
+    return ffurl_get_short_seek(s->tls_shared.tcp);
+}
+
+static const AVOption options[] = {
+    TLS_COMMON_OPTIONS(TLSContext, tls_shared),
+    { NULL }
+};
+
+static const AVClass tls_class = {
+    .class_name = "tls",
+    .item_name  = av_default_item_name,
+    .option     = options,
+    .version    = LIBAVUTIL_VERSION_INT,
+};
+
+const URLProtocol ff_tls_protocol = {
+    .name           = "tls",
+    .url_open2      = tls_open,
+    .url_read       = tls_read,
+    .url_write      = tls_write,
+    .url_close      = tls_close,
+    .url_get_file_handle = tls_get_file_handle,
+    .url_get_short_seek  = tls_get_short_seek,
+    .priv_data_size = sizeof(TLSContext),
+    .flags          = URL_PROTOCOL_FLAG_NETWORK,
+    .priv_data_class = &tls_class,
+};
